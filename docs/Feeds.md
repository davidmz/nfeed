# Фиды

> Предупреждение: это не готовая к использованию модель данных, а только общий набросок. Не все моменты полностью проработаны, не на все вопросы у автора есть ответы.

**Задача**: обеспечить генерацию френд- и прочих лент пользователя за минимальное время, то есть, за ~1 запрос к базе данных с использованием ~1 индекса.

## Модель постов-лент-каналов на высоком уровне 

Она несколько шире чем нынешняя модель ФрФ и включает последнюю как подмножество:

* *Посты* публикуются пользователями-авторами, у каждого поста есть ровно один автор.
* Авторы публикуют посты в *каналы*: собственный блог, группы и т. д.
* С точки зрения доступа на чтение, канал может быть:
    * *публичным* (public) — его может читать любой, даже не авторизованный, пользователь.
    * *защищённые* (protected) — его могут читать все, кроме неавторизованных пользователей и пользователей из явно определённого набора.
    * *приватным* (private) — его может читать только ограниченное подмножество авторизованных пользователей.
* С точки зрения доступа на запись, в канал может писать один пользователь, группа пользователей или все пользователи.
* Вопросы управление группами читателей / писателей находится вне рассмотрения этого документа.
* Пользователь имеет один или более *собственных* каналов. В собственный канал может писать только сам пользователь, он же может управлять доступом на чтение этого канала.
* Пользователь-читатель читает посты в *лентах*. Если он читает чей-то канал, то лента — это представление этого канала, все посты из него, видимые читателю. Но ленты может формироваться и иными путями (более строго это будет описано в модели данных).
* Существуют автогенерируемые ленты без авторов, например, лента всех постов, прокомментированных (или лайкнутых) неким пользователем, лента всех постов с неким хэштегом и т. д.
* Существуют ленты-агрегаторы, собирающие в себя посты из нескольких других лент.
* По умолчанию пользователь имеет одну ленту-агрегатор — френдленту. В неё собираются ленты пользователей, на которых он подписан, а также ленты прокомментированных и лайкнутых ими постов.
* Пользователь может создавать дополнительные френдленты с другим составом пользователей-френдов.

## Модель данных

### Фиды

Система фидов моделирует систему каналов и лент на них на низком уровне.

Фид — это упорядоченная коллекция постов. Один и тот же пост может принадлежать нескольким фидам. Фиды бывают следующих видов:

* **Базовые (или первичные) фиды** — это фиды, в которые пользователь помещает посты сам. Это фид(ы) самого пользователя, фиды коммьюнити и директ-фиды.

* **Фиды-фильтры** — в них посты помещаются автоматически по наличию в посте какого-либо признака. В нынешней модели это фиды постов, прокомментированных или лайкнутых пользователем. Такими фидами также могут быть фиды с упоминанием пользователя, фиды с хэштегами и так далее. Это частичная и более оптимизированная (?) замена поиска. *Замечание*: возможно, этот тип фидов не нужен, если есть хороший поиск.

* **Фиды-агрегаторы** — это фиды, собирающие в себя посты из первичных и фильтрующих фидов. Фиды-агрегаторы *подписаны* на  базовые фиды и фиды-фильтры. Фиды-агрегаторы всегда работают от имени конкретного пользователя и видимы только ему.

Фиды-агрегаторы — это **френдлента** пользователя (их может быть несколько для разных наборов френдов), а также вспомогательные ленты (см. раздел «просмотр фильтрующих фидов»):
* **PrivateForUser** — лента всех приватных постов, видимых пользователю.
* **ProtectedFromUser** — лента всех защишённых постов, невидимых пользователю.

### Подтипы фидов
Для каждого пользователя есть:
* Базовые фиды (+их числовые типы):
    * [1] Собственный фид для своих постов. Писать может только владелец. Возможно создание нескольких таких фидов.
    * [3] Директ-фид. Читать может только владелец.
* Фильтры:
    * [1] Все посты, прокомментированные данным пользователем.
    * [2] Все посты, лайкнутые данным пользователем.
* Агрегаторы:
    * [1] Френдлента. Читать может только владелец. Возможно, несколько френдлент разного состава. По умолчанию во френдленту собираются:
        * Собственные фиды друзей, групп и себя самого.
        * Фиды-фильтры друзей и себя самого — прокомментированные и лайкнутые посты.
        * Директ-фид пользователя.
    * [2] PrivateForUser — служебный фид, явно нигде не показывается.
    * [3] ProtectedFromUser — служебный фид, явно нигде не показывается.

Помимо этого существуют:
* Базовые фиды:
    * [2] Фиды групп. Права записи и чтения определяются политикой группы.
* Фильтры:
    * [3] Посты, содержащие определённый хэштег.
    * [4] Посты, в которых упоминается определённый пользователь.
    * …


### Права на чтение постов

Права на чтение задаются на уровне базовых фидов. Каждый базовый фид для каждого пользователя либо полностью виден, либо полностью не виден.

Базовые фиды могут иметь следующие правила доступа на чтение:
* [0] **Публичный фид** — могут читать все, в том числе неавторизованные.
* [1] **Защищённый фид** — могут читать все, кроме неавторизованных и пользователей из явно определённого набора.
* [2] **Приватный фид** — могут читать только пользователи из явно определённого набора.

Если у пользователя есть право чтения базового фида, то у него есть право чтения любого поста, принадлежащего фиду. Обратное: если пост входит хотя бы в один базовый фид, видимый пользователю, то он виден пользователю.

> Пусть пост принадлежит фидам F1 и F2, и его читает пользователь U, причём F1 — приватный, и U входит в число его читателей, а F2 — защищённый, и U входит в число забаненных. В этом случае пользователь должен видеть этот пост.  

### Свойства фида
Таблица **feeds** имеет как минимум следующие поля:

	id int
	type int       -- тип фида: базовый, фильтр, аггрегатор
	subtype int    -- конкретная разновидность фида в пределах типа
	access int     -- тип доступа на чтение
	user_id int    -- ID юзера, который владеет фидом-агрегатором 
	                  или собственным базовым фидом.

### Подписка
Фиды-агрегаторы подписаны на базовые и фильтрующие фиды. Подписка реализуется очевидным образом — таблицей **feed_subscr** с полями: (**src_feed_id**, **tgt_feed_id**).

Примеры: 
* Если юзер А подписан на юзера Б, то фид-агрегатор «френдлента юзера А» подписана на фиды: «лента юзера Б», «посты, прокомментированные юзером Б», «посты, лайкнутые юзером Б».
* Если юзер Б имеет приватный канал, доступный для чтения пользователю А, то агрегатор PrivateForUser подписан на приватный канал Б, даже если Б не в друзьях у А.

Таблица отражает только факт подписки, само попадание постов из src_feed в tgt_feed определяется логикой приложения:
* Френдлента — попадают все посты, которые видимы владельцу агрегатора.
* PrivateForUser — попадают непубличные посты, которые видимы владельцу агрегатора.
* ProtectedFromUser — попадают защищённые посты, которые не видимы владельцу агрегатора.

### Структура фида
Таблица связи фид — пост (**feed_posts**):

    feed_id int     -- id фида
    post_id int     -- id поста.
    is_public       -- пост входит хотя бы в один публичный фид
    is_protected    -- пост входит хотя бы в один защищённый фид    
    is_private      -- пост входит хотя бы в один приватный фид    
    ord int         -- порядок поста в фиде (чем он больше, тем выше пост).
    time_ord int    -- порядок поста по времени создания 
                       (чем он больше, тем позже пост создан), 
                       нужен для возможности сортировки фида 
                       по времени создания поста.

### Всплывание постов
Посты могут всплывать (переноситься на первое место в фиде) по определённым событиям в их жизни. Правила всплывания:

* Пост всплывает во всех фидах, где он есть, если:
    * К посту оставлен новый комментарий, при этом пост моложе 1 суток или в течение последних суток оставлено более 2 комментариев;
    * Любая другая всплывательная магия.
* Пост всплывает в агрегирующем или фильтрующем фиде, если он попал в этот фид по событию поста (см. ниже).

За всплывание отвечает поле *ord*. Существует глобальный монотонно возрастающий счётчик (sequence в PostgreSQL).

При создании поста счётчик увеличивается на 1 и полученное значение записывается как ord и time_ord поста в фидах, в которые попадает этот пост.

При всплытии поста, новое значение счётчика записывается как ord во всех фидах, где есть пост. При insert-е поста в фид, новое значение счётчика записывается как ord в данном фиде.

### Изменения и события
События, приводящие к изменению фидов, могут быть двух типов: события в постах и события в фидах.
#### События в постах
Посты могут добавляться в первичные и фильтрующие фиды и удаляться из них.

Добавлением в первичные фиды управляет сам пользователь, выбирая, в каких лентах или группах опубликовать пост. Возможна схема, при которой пользователь может постфактум изменить состав базовых фидов поста.

В фиды-фильтры посты попадают автоматически, в зависимости от свойств самого поста. Например, если к посту добавился комментарий нового пользователя, то пост добавляется в фид-фильтр прокомментированных постов этого пользователя.

Добавление/удаление постов в в первичные и фильтрующие фиды производится синхронно, после чего запускается (возможно, фоновый асинхронный) процесс обновления агрегаторов.

##### Добавление постов
Пусть пост (POST_ID) добавился в несколько фидов (SRC_IDS). Выбираются агрегаторы, подписанные на эти фиды, и не содержащие этого поста.

    select distinct s.tgt_id from
    	feed_subscr s
    	left join feed_posts p on s.tgt_id = p.feed_id and p.post_id = POST_ID
    where s.src_id in (SRC_IDS) and p.post_id is null

Далее (если пост не публичный) каждый из этих фидов проверяется на право чтения поста, и если оно есть, то пост добавляется в фид со всплыванием.

##### Удаление постов
Если пост удаляется из системы полностью, то всё просто: `delete from feed_posts where post_id = POST_ID` (или то же самое делается автоматически при помощи внешних ключей).

Если пост удаляется только из некоторых фидов, то всё немного сложнее. Сначала выбираются агрегаторы, в которых есть этот пост, и которые подписаны на фиды, откуда пост исчез:

    select distinct s.tgt_id from
    	feed_subscr s
    	join feed_posts p on s.tgt_id = p.feed_id and p.post_id = POST_ID
    where s.src_id in (SRC_IDS)

Потом для каждого агрегатора проверяется новая видимость поста, и, в зависимости от результатов проверки, он либо удаляется из фида, либо остаётся в нём.

#### События в фидах
События в фидах бывают двух типов: а) агрегатор подписался на фид или отписался от него или б) фид изменил свою видимость для агрегатора (перешёл в приватный режим, владелец агрегатора перестал быть «другом» владельца фида или наоборот…).

Такие события затрагивают сразу множество постов, поэтому обновление постов производится асинхронно, фоновым процессом и небольшими блоками постов. Разумно первыми обрабатывать посты с максимальным time_ord, в этом случае конкретное задание на обработку может выглядеть как [operation, src_feed, dest_feed, max_ord_processed]. По мере обработки, max_ord_processed уменьшается, пока процесс не будет завершён.

Посты, добавленные в агрегаторы таким способом, не всплывают, а наследуют ord от базового фида-источника.

### Очерёдность обработки событий
Возможна ситуация, когда пользователь ушёл в приват, а потом сразу же вышел из него. Или удалил свой лайк, а потом снова лайкнул пост. Чтобы сохранить согласованность изменений в таком случае, фоновые обработчики должны действовать упорядочено. Как это реализовать конкретно — надо думать.

## Просмотр фидов
### Базовые фиды и фиды-агрегаторы
Если у зрителя есть право просмотра базового фида или он является владельцем фида-агрегатора, то выборка постов делается простым запросом: 

    select post_id from feed_posts where feed_id = FEED_ID

В противном случае зритель не видит ничего.

### Фильтрующие фиды
Если зритель не авторизован, то выборка проста: `select post_id from feed_posts where feed_id = FEED_ID and is_public`

Если зритель авторизован, то ситуация сложнее, поскольку в фильтрующий фид попадают посты из разных базовых фидов с разными правами просмотра.

Для решения проблемы используются служебные агрегаторы PrivateForUser (P_FEED_ID) и ProtectedFromUser (H_FEED_ID). В таком случае запрос получается следующим:

    select f.post_id 
    from 
        feed_posts f 
        left join feed_posts p on f.post_id = p.post_id and p.feed_id = P_FEED_ID
        left join feed_posts h on f.post_id = h.post_id and h.feed_id = H_FEED_ID        
    where 
        f.feed_id = FEED_ID 
        and (
            is_public
            or is_protected and h.post_id is null 
            or is_private   and p.post_id is not null 
        )

### Директы
У каждого пользователя есть свой базовый директ-фид, который может читать только сам пользователь, и в которые могут писать те, кто может пользователю посылать директы. Если А отправляет директ пользователю Б, то директ-пост публикуется в директ-фидах А и Б.

Страница `/filter/direct` представляет собой директ-фид текущего пользователя.

### Проблемы
#### Дублирование данных
Очевидная проблема — большое количество дублирующихся данных в feed_posts.

По прикидкам, наибольшее число записей будет содержаться в фидах-френдлентах. Если у нас есть N пользователей, каждый написал M постов и у каждого K друзей, то общий объём френдлент составит N×M×K записей. Для достаточно умеренных значений N, M, K = 1000, 1000, 20 получим 20М записей. N и M со временем растут более-менее линейно, а число записей растёт как их произведение. Ну и число френдов тоже, скорее всего, будет подрастать. При этом подавляющее большинство записей будут одинаковыми, и отличаться только feed_id.

Наиболее простой и радикальный метод борьбы — ограничить глубину френдленты. Если максимальная глубина френдленты — L, то число записей будет максимум N×L, независимо от числа френдов и числа их постов. Остаётся линейная зависимость только от числа пользователей. Для L = 1000 предыдущий пример даёт всего 1М записей.

Ограничение глубины френдленты требует наличия на сайте поиска.

Возможные проблемы: слегка ломается алгоритм всплывания постов. Если раньше пост всплывал при первом своём попадании в фид, то теперь могут случаться повторные «первые» попадания, потому что пост ранее ушёл за границу L постов и был удалён. Вероятно, это можно решить регулировкой алгоритма всплывания (скажем, не поднимать таким образом вовсе посты старше определённого времени).

Также можно ограничить объём фидов PrivateForUser. Однако, фиды ProtectedFromUser ограничивать нельзя т. к. это приведёт к раскрытию постов, которые не должны быть видны данному пользователю. Правда, эти посты всё равно можно увидеть, авторизовавшись под другим пользователем…  

#### Шардинг и вообще масштабирование

Достаточно естественным выглядит шардинг feed_posts по feed_id. Все описанные выше операции такой шардинг переживают спокойно, кроме одной, но важной — просмотра фильтрующих фидов. Там используется явный джойн двух фидов, которые могут находиться в разных шардах.

Напрашивается динамический джойн вне базы. Но т. к. тут используется не простой union двух фидов, а более хитрое объединение, то в худшем случае потребуется много запросов к обоим фидам. Например, когда у нас большой и часто обновляющийся фильтрующий фид, большинство записей которого — приватные, и только небольшая часть из них доступна текущему читателю.
